<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.MD">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.MD" />
              <option name="updatedContent" value="# MVTS Problem Statement Designer&#10;&#10;A comprehensive tool for designing and solving Multi-Vehicle Task Scheduling (MVTS) problem statements with real-time visualization and optimization capabilities.&#10;&#10;## ️ Architecture&#10;&#10;This project consists of two main components:&#10;&#10;- **Backend Server**: Java-based WebSocket server with REST API endpoints&#10;- **Frontend UI**: React-based web application with interactive grid editor&#10;&#10;##  Features&#10;&#10;### Problem Statement Design&#10;- Interactive grid-based warehouse layout editor&#10;- Entity management (Bots, MSUs, PPSs, Tasks, Assignments)&#10;- Template system for quick problem setup&#10;- Real-time problem statement validation&#10;- JSON export/import capabilities&#10;&#10;### Multi-Client Support&#10;- Multiple clients can connect simultaneously&#10;- Sequential processing queue (one request at a time)&#10;- Real-time queue status updates for all clients&#10;- Automatic client disconnect detection and task termination&#10;&#10;### Solution Visualization&#10;- Real-time solution display with animated bot movements&#10;- Task assignments and scheduling visualization&#10;- Performance metrics and optimization results&#10;- Interactive solution viewer with step-by-step playback&#10;&#10;### WebSocket Communication&#10;- Real-time bidirectional communication&#10;- Live log streaming during processing&#10;- Queue position tracking&#10;- Automatic reconnection handling&#10;&#10;##  Prerequisites&#10;&#10;### Backend Requirements&#10;- **Java 17** or higher&#10;- **Maven 3.6+** for dependency management&#10;- **GreyOrange MultiFleet Planner** library (internal dependency)&#10;&#10;### Frontend Requirements&#10;- **Node.js 16+**&#10;- **npm 8+** or **yarn 1.22+**&#10;&#10;## ️ Installation &amp; Setup&#10;&#10;### 1. Clone the Repository&#10;```bash&#10;git clone &lt;repository-url&gt;&#10;cd MVTSProblemStatementDesigner&#10;```&#10;&#10;### 2. Backend Setup&#10;&#10;#### Install Dependencies&#10;```bash&#10;cd server&#10;mvn clean install&#10;```&#10;&#10;#### Build the Project&#10;```bash&#10;mvn compile&#10;```&#10;&#10;#### Create Executable JAR&#10;```bash&#10;mvn package&#10;```&#10;&#10;### 3. Frontend Setup&#10;&#10;#### Install Dependencies&#10;```bash&#10;cd ui/mvts-problem-statement-generator&#10;npm install&#10;```&#10;&#10;#### Build for Production&#10;```bash&#10;npm run build&#10;```&#10;&#10;##  Deployment&#10;&#10;### Development Environment&#10;&#10;#### Start Backend Server&#10;```bash&#10;cd server&#10;mvn exec:java -Dexec.mainClass=&quot;com.greyorange.mvts.designer.ProblemStatementStudio&quot;&#10;```&#10;&#10;The server will start on `http://localhost:8080`&#10;&#10;#### Start Frontend Development Server&#10;```bash&#10;cd ui/mvts-problem-statement-generator&#10;npm start&#10;```&#10;&#10;The UI will be available at `http://localhost:3000`&#10;&#10;### Production Deployment&#10;&#10;#### Option 1: JAR Deployment&#10;&#10;1. **Build the JAR**:&#10;```bash&#10;cd server&#10;mvn clean package&#10;```&#10;&#10;2. **Run the JAR**:&#10;```bash&#10;java -jar target/MVTSProblemStatementDesigner-1.0-SNAPSHOT.jar&#10;```&#10;&#10;3. **Serve Static Files**:&#10;   - Build the frontend: `cd ui/mvts-problem-statement-generator &amp;&amp; npm run build`&#10;   - Serve the `build` folder using a web server (nginx, Apache, etc.)&#10;   - Configure proxy to forward API calls to the Java backend&#10;&#10;#### Option 2: Docker Deployment&#10;&#10;1. **Create Dockerfile for Backend**:&#10;```dockerfile&#10;FROM openjdk:17-jdk-slim&#10;COPY target/MVTSProblemStatementDesigner-1.0-SNAPSHOT.jar app.jar&#10;EXPOSE 8080&#10;ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;]&#10;```&#10;&#10;2. **Create Dockerfile for Frontend**:&#10;```dockerfile&#10;FROM node:16-alpine AS build&#10;WORKDIR /app&#10;COPY package*.json ./&#10;RUN npm install&#10;COPY . .&#10;RUN npm run build&#10;&#10;FROM nginx:alpine&#10;COPY --from=build /app/build /usr/share/nginx/html&#10;COPY nginx.conf /etc/nginx/nginx.conf&#10;EXPOSE 80&#10;```&#10;&#10;3. **Docker Compose**:&#10;```yaml&#10;version: '3.8'&#10;services:&#10;  backend:&#10;    build: ./server&#10;    ports:&#10;      - &quot;8080:8080&quot;&#10;  &#10;  frontend:&#10;    build: ./ui/mvts-problem-statement-generator&#10;    ports:&#10;      - &quot;80:80&quot;&#10;    depends_on:&#10;      - backend&#10;```&#10;&#10;#### Option 3: Cloud Deployment (AWS/GCP/Azure)&#10;&#10;1. **Container Registry**:&#10;   - Build and push Docker images to your cloud provider's container registry&#10;&#10;2. **Container Service**:&#10;   - Deploy using services like ECS, Cloud Run, or Azure Container Instances&#10;&#10;3. **Load Balancer**:&#10;   - Configure load balancer to distribute traffic and handle SSL termination&#10;&#10;## ⚙️ Configuration&#10;&#10;### Backend Configuration&#10;&#10;Configuration is managed through `ApplicationProperties` class:&#10;&#10;- **Server Port**: Default `8080`&#10;- **WebSocket Endpoint**: `/websocket`&#10;- **REST API Endpoint**: `/api`&#10;&#10;### Frontend Configuration&#10;&#10;Update API endpoints in `src/hooks/useServerAPI.js`:&#10;&#10;```javascript&#10;const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8080';&#10;const WS_BASE_URL = process.env.REACT_APP_WS_URL || 'ws://localhost:8080';&#10;```&#10;&#10;### Environment Variables&#10;&#10;Create `.env` files for different environments:&#10;&#10;```bash&#10;# .env.production&#10;REACT_APP_API_URL=https://your-api-domain.com&#10;REACT_APP_WS_URL=wss://your-api-domain.com&#10;```&#10;&#10;##  API Endpoints&#10;&#10;### WebSocket Events&#10;- `PING` / `PONG`: Connection health check&#10;- `SOLVE_PROBLEM_STATEMENT`: Submit problem for solving&#10;- `QUEUE_STATUS`: Real-time queue updates&#10;- `PROBLEM_STATEMENT_SOLVED`: Solution results&#10;&#10;### REST API&#10;- `GET /api/health`: Health check&#10;- `POST /api/solve`: Submit problem statement&#10;- `GET /api/status`: Get system status&#10;&#10;##  Development&#10;&#10;### Backend Development&#10;```bash&#10;cd server&#10;mvn compile exec:java -Dexec.mainClass=&quot;com.greyorange.mvts.designer.ProblemStatementStudio&quot;&#10;```&#10;&#10;### Frontend Development&#10;```bash&#10;cd ui/mvts-problem-statement-generator&#10;npm start&#10;```&#10;&#10;### Running Tests&#10;```bash&#10;# Backend tests&#10;cd server&#10;mvn test&#10;&#10;# Frontend tests&#10;cd ui/mvts-problem-statement-generator&#10;npm test&#10;```&#10;&#10;##  Troubleshooting&#10;&#10;### Common Issues&#10;&#10;1. **Port Already in Use**:&#10;   - Change server port in configuration&#10;   - Kill existing processes: `lsof -ti:8080 | xargs kill -9`&#10;&#10;2. **WebSocket Connection Failed**:&#10;   - Check firewall settings&#10;   - Verify WebSocket endpoint configuration&#10;   - Ensure backend server is running&#10;&#10;3. **Build Failures**:&#10;   - Verify Java version: `java -version`&#10;   - Check Maven configuration: `mvn -version`&#10;   - Clear npm cache: `npm cache clean --force`&#10;&#10;4. **Memory Issues**:&#10;   - Increase JVM heap size: `java -Xmx4g -jar app.jar`&#10;   - Monitor system resources during processing&#10;&#10;### Logs and Debugging&#10;&#10;- **Backend Logs**: Check console output or configure logback for file logging&#10;- **Frontend Logs**: Open browser developer tools console&#10;- **WebSocket Traffic**: Use browser Network tab to monitor WebSocket messages&#10;&#10;##  Contributing&#10;&#10;1. Fork the repository&#10;2. Create a feature branch: `git checkout -b feature/amazing-feature`&#10;3. Commit changes: `git commit -m 'Add amazing feature'`&#10;4. Push to branch: `git push origin feature/amazing-feature`&#10;5. Open a Pull Request&#10;&#10;##  License&#10;&#10;This project is proprietary software owned by GreyOrange. Unauthorized distribution is prohibited.&#10;&#10;##  Support&#10;&#10;For technical support and questions:&#10;- Internal Documentation: [Internal Wiki/Confluence Link]&#10;- Team Contact: [Team Email/Slack Channel]&#10;- Issue Tracking: [JIRA/Internal Issue Tracker]&#10;&#10;---&#10;&#10;**Last Updated**: August 2025&#10;**Version**: 1.0-SNAPSHOT" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/greyorange/mvts/designer/PSStudioWebSocketHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/greyorange/mvts/designer/PSStudioWebSocketHandler.java" />
              <option name="originalContent" value="package com.greyorange.mvts.designer;&#10;&#10;import com.fasterxml.jackson.databind.JsonNode;&#10;import com.greyorange.multifleetplanner.helpers.Helper;&#10;import com.greyorange.mvts.designer.pojo.WSData;&#10;import com.greyorange.mvts.designer.pojo.WSEvent;&#10;import org.eclipse.jetty.websocket.api.Session;&#10;import org.eclipse.jetty.websocket.api.annotations.*;&#10;&#10;import java.io.IOException;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.concurrent.*;&#10;import java.util.UUID;&#10;&#10;@WebSocket&#10;public class PSStudioWebSocketHandler {&#10;  private static final CopyOnWriteArraySet&lt;Session&gt; sessions = new CopyOnWriteArraySet&lt;&gt;();&#10;&#10;  // Queue for managing sequential problem solving requests&#10;  private static final BlockingQueue&lt;QueuedRequest&gt; problemSolvingQueue = new LinkedBlockingQueue&lt;&gt;();&#10;  private static final ExecutorService sequentialExecutor = Executors.newSingleThreadExecutor();&#10;  private static volatile String currentlyProcessingRequestId = null;&#10;&#10;  /**&#10;   * Internal class to track queued requests with metadata&#10;   */&#10;  private static class QueuedRequest {&#10;    private final String requestId;&#10;    private final Session session;&#10;    private final String inputMessage;&#10;    private final Map&lt;String, String&gt; configs;&#10;&#10;    public QueuedRequest(String requestId, Session session, String inputMessage, Map&lt;String, String&gt; configs) {&#10;      this.requestId = requestId;&#10;      this.session = session;&#10;      this.inputMessage = inputMessage;&#10;      this.configs = configs;&#10;    }&#10;&#10;    public String getRequestId() { return requestId; }&#10;    public Session getSession() { return session; }&#10;    public String getInputMessage() { return inputMessage; }&#10;    public Map&lt;String, String&gt; getConfigs() { return configs; }&#10;  }&#10;&#10;  static {&#10;    // Start the queue processor&#10;    startQueueProcessor();&#10;  }&#10;&#10;  /**&#10;   * Starts the queue processor that handles problem solving requests sequentially&#10;   */&#10;  private static void startQueueProcessor() {&#10;    sequentialExecutor.submit(() -&gt; {&#10;      while (!Thread.currentThread().isInterrupted()) {&#10;        try {&#10;          // Take the next task from queue (blocks if queue is empty)&#10;          QueuedRequest request = problemSolvingQueue.take();&#10;          currentlyProcessingRequestId = request.getRequestId();&#10;&#10;          // Update all clients about the current processing status&#10;          broadcastQueueStatus();&#10;&#10;          // Execute the request&#10;          processRequest(request);&#10;&#10;          currentlyProcessingRequestId = null;&#10;          // Update all clients after processing completes&#10;          broadcastQueueStatus();&#10;&#10;        } catch (InterruptedException e) {&#10;          Thread.currentThread().interrupt();&#10;          break;&#10;        } catch (Exception e) {&#10;          System.err.println(&quot;Error processing problem solving queue: &quot; + e.getMessage());&#10;          currentlyProcessingRequestId = null;&#10;        }&#10;      }&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Processes a single request&#10;   */&#10;  private static void processRequest(QueuedRequest request) {&#10;    Session session = request.getSession();&#10;&#10;    try {&#10;      // Check if session is still valid&#10;      if (!session.isOpen()) {&#10;        System.out.println(&quot;Session closed, skipping request: &quot; + request.getRequestId());&#10;        return;&#10;      }&#10;&#10;      // Notify the specific client that processing has started&#10;      sendToSession(session, &quot;{\&quot;type\&quot;:\&quot;SOLVING_PROBLEM_STATEMENT\&quot;, \&quot;data\&quot;:{\&quot;requestId\&quot;:\&quot;&quot; + request.getRequestId() + &quot;\&quot;, \&quot;log\&quot;:\&quot;Processing started for your request...\&quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}}&quot;);&#10;&#10;      // Solve the problem&#10;      String result = ProblemStatementStudio.getInstance().solve(request.getInputMessage(), request.getConfigs());&#10;&#10;      // Send completion message to the specific client&#10;      sendToSession(session, &quot;{\&quot;type\&quot;:\&quot;PROBLEM_STATEMENT_SOLVED\&quot;, \&quot;data\&quot;:{\&quot;requestId\&quot;:\&quot;&quot; + request.getRequestId() + &quot;\&quot;, \&quot;result\&quot;:&quot; + result + &quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}}&quot;);&#10;&#10;    } catch (Exception e) {&#10;      String errorMsg = &quot;Error while solving problem statement: &quot; + e.getMessage();&#10;      try {&#10;        sendToSession(session, &quot;{\&quot;type\&quot;:\&quot;PROBLEM_STATEMENT_SOLVED\&quot;, \&quot;data\&quot;:{\&quot;requestId\&quot;:\&quot;&quot; + request.getRequestId() + &quot;\&quot;, \&quot;error\&quot;:\&quot;&quot; + errorMsg + &quot;\&quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}}&quot;);&#10;      } catch (Exception sendException) {&#10;        System.err.println(&quot;Error sending error message: &quot; + sendException.getMessage());&#10;      }&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Broadcasts queue status to all connected clients&#10;   */&#10;  private static void broadcastQueueStatus() {&#10;    int queueSize = problemSolvingQueue.size();&#10;    String status = &quot;{\&quot;type\&quot;:\&quot;QUEUE_STATUS\&quot;, \&quot;data\&quot;:{\&quot;queueSize\&quot;:&quot; + queueSize +&#10;                   &quot;, \&quot;currentlyProcessing\&quot;:\&quot;&quot; + (currentlyProcessingRequestId != null ? currentlyProcessingRequestId : &quot;&quot;) +&#10;                   &quot;\&quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}}&quot;;&#10;&#10;    broadcastToAllSessions(status);&#10;  }&#10;&#10;  /**&#10;   * Sends a message to all connected sessions&#10;   */&#10;  private static void broadcastToAllSessions(String message) {&#10;    for (Session session : sessions) {&#10;      sendToSession(session, message);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Safely sends a message to a specific session&#10;   */&#10;  private static void sendToSession(Session session, String message) {&#10;    try {&#10;      if (session.isOpen()) {&#10;        session.getRemote().sendString(message);&#10;      }&#10;    } catch (IOException e) {&#10;      System.err.println(&quot;Error sending message to session: &quot; + e.getMessage());&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Interface for streaming logs back to the client during problem solving&#10;   */&#10;  public interface LogStreamer {&#10;    void streamLog(String logMessage);&#10;    void streamError(String errorMessage);&#10;    void streamComplete(String result);&#10;  }&#10;&#10;  @OnWebSocketConnect&#10;  public void onConnect(Session session) {&#10;    try {&#10;      sessions.add(session);&#10;      // Register session for log streaming&#10;      WebSocketLogAppender.addSession(session);&#10;      System.out.println(&quot;Client connected: &quot; + session + &quot; (Total clients: &quot; + sessions.size() + &quot;)&quot;);&#10;&#10;      // Send welcome message with current queue status&#10;      int queueSize = problemSolvingQueue.size();&#10;      String welcomeMessage = &quot;{\&quot;type\&quot;:\&quot;CONNECTED\&quot;, \&quot;data\&quot;:{\&quot;message\&quot;:\&quot;Connected successfully\&quot;, \&quot;queueSize\&quot;:&quot; + queueSize +&#10;                             &quot;, \&quot;currentlyProcessing\&quot;:\&quot;&quot; + (currentlyProcessingRequestId != null ? currentlyProcessingRequestId : &quot;&quot;) +&#10;                             &quot;\&quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}}&quot;;&#10;      sendToSession(session, welcomeMessage);&#10;&#10;    } catch (Exception e) {&#10;      e.printStackTrace();&#10;    }&#10;  }&#10;&#10;  @OnWebSocketMessage&#10;  public void onMessage(Session session, String message) throws IOException {&#10;    try {&#10;      WSData data = Helper.getObjectMapper().readValue(message, WSData.class);&#10;      if (data.getEvent().equals(WSEvent.PING)) {&#10;        sendToSession(session, &quot;{\&quot;type\&quot;:\&quot;PONG\&quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}&quot;);&#10;      }&#10;&#10;      if (data.getEvent().equals(WSEvent.SOLVE_PROBLEM_STATEMENT)) {&#10;        handleSolveProblemStatement(session, data.getDataNode());&#10;      } else {&#10;        System.err.println(&quot;Unknown event type: &quot; + data.getEvent());&#10;      }&#10;&#10;    } catch (Exception e) {&#10;      System.err.println(&quot;Error parsing message: &quot; + message);&#10;      e.printStackTrace();&#10;      sendToSession(session, &quot;{\&quot;type\&quot;:\&quot;ERROR\&quot;, \&quot;message\&quot;:\&quot;Invalid message format\&quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}&quot;);&#10;    }&#10;  }&#10;&#10;  @OnWebSocketClose&#10;  public void onClose(Session session, int statusCode, String reason) {&#10;    sessions.remove(session);&#10;    // Unregister session from log streaming&#10;    WebSocketLogAppender.removeSession(session);&#10;    System.out.println(&quot;Client disconnected: &quot; + reason + &quot; (Remaining clients: &quot; + sessions.size() + &quot;)&quot;);&#10;&#10;    // Remove any pending requests from this session from the queue&#10;    problemSolvingQueue.removeIf(request -&gt; request.getSession().equals(session));&#10;&#10;    // Broadcast updated queue status to remaining clients&#10;    broadcastQueueStatus();&#10;  }&#10;&#10;  @OnWebSocketError&#10;  public void onError(Session session, Throwable throwable) {&#10;    System.err.println(&quot;Error in session &quot; + session + &quot;: &quot; + throwable.getMessage());&#10;    throwable.printStackTrace();&#10;  }&#10;&#10;  // Helper methods to handle different events&#10;&#10;  /**&#10;   * Handles the SOLVE_PROBLEM_STATEMENT event.&#10;   * Adds the request to a queue for sequential processing to prevent concurrent executions.&#10;   * Provides queue position feedback to the client and broadcasts status to all clients.&#10;   *&#10;   * @param session The WebSocket session of the client.&#10;   * @param dataNode The JSON data node containing the problem statement details.&#10;   */&#10;  private void handleSolveProblemStatement(Session session, JsonNode dataNode) {&#10;    String requestId = UUID.randomUUID().toString();&#10;    String inputMessage = dataNode.get(&quot;problemStatement&quot;).toString();&#10;&#10;    JsonNode configNode = dataNode.get(&quot;config&quot;);&#10;    Map&lt;String, String&gt; configs = new HashMap&lt;&gt;();&#10;&#10;    // Flatten configNode if present&#10;    if (configNode != null &amp;&amp; !configNode.isNull()) {&#10;      flattenJson(configNode, &quot;&quot;, configs);&#10;    }&#10;&#10;    // Create queued request&#10;    QueuedRequest queuedRequest = new QueuedRequest(requestId, session, inputMessage, configs);&#10;&#10;    // Get current queue position (before adding)&#10;    int queuePosition = problemSolvingQueue.size() + 1;&#10;&#10;    // Add to queue&#10;    problemSolvingQueue.offer(queuedRequest);&#10;&#10;    // Notify the requesting client about queue position&#10;    try {&#10;      if (queuePosition == 1 &amp;&amp; currentlyProcessingRequestId == null) {&#10;        sendToSession(session, &quot;{\&quot;type\&quot;:\&quot;SOLVING_PROBLEM_STATEMENT\&quot;, \&quot;data\&quot;:{\&quot;requestId\&quot;:\&quot;&quot; + requestId + &quot;\&quot;, \&quot;log\&quot;:\&quot;Request queued - processing will start shortly...\&quot;, \&quot;queuePosition\&quot;:&quot; + queuePosition + &quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}}&quot;);&#10;      } else {&#10;        sendToSession(session, &quot;{\&quot;type\&quot;:\&quot;SOLVING_PROBLEM_STATEMENT\&quot;, \&quot;data\&quot;:{\&quot;requestId\&quot;:\&quot;&quot; + requestId + &quot;\&quot;, \&quot;log\&quot;:\&quot;Request queued at position &quot; + queuePosition + &quot;. Waiting for previous requests to complete...\&quot;, \&quot;queuePosition\&quot;:&quot; + queuePosition + &quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}}&quot;);&#10;      }&#10;    } catch (Exception e) {&#10;      System.err.println(&quot;Error sending queue position message: &quot; + e.getMessage());&#10;    }&#10;&#10;    // Broadcast queue status update to all clients&#10;    broadcastQueueStatus();&#10;  }&#10;&#10;  /**&#10;   * Recursively flattens a JsonNode into a dot-notated map.&#10;   */&#10;  private void flattenJson(JsonNode node, String prefix, Map&lt;String, String&gt; result) {&#10;    if (node.isObject()) {&#10;      node.fieldNames().forEachRemaining(fieldName -&gt; {&#10;        String newPrefix = prefix.isEmpty() ? fieldName : prefix + &quot;.&quot; + fieldName;&#10;        flattenJson(node.get(fieldName), newPrefix, result);&#10;      });&#10;    } else if (node.isArray()) {&#10;      for (int i = 0; i &lt; node.size(); i++) {&#10;        String newPrefix = prefix + &quot;[&quot; + i + &quot;]&quot;;&#10;        flattenJson(node.get(i), newPrefix, result);&#10;      }&#10;    } else { // Value node&#10;      result.put(prefix, node.asText());&#10;    }&#10;  }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.greyorange.mvts.designer;&#10;&#10;import com.fasterxml.jackson.databind.JsonNode;&#10;import com.greyorange.multifleetplanner.helpers.Helper;&#10;import com.greyorange.mvts.designer.pojo.WSData;&#10;import com.greyorange.mvts.designer.pojo.WSEvent;&#10;import org.eclipse.jetty.websocket.api.Session;&#10;import org.eclipse.jetty.websocket.api.annotations.*;&#10;&#10;import java.io.IOException;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.concurrent.*;&#10;import java.util.UUID;&#10;&#10;@WebSocket&#10;public class PSStudioWebSocketHandler {&#10;  private static final CopyOnWriteArraySet&lt;Session&gt; sessions = new CopyOnWriteArraySet&lt;&gt;();&#10;&#10;  // Queue for managing sequential problem solving requests&#10;  private static final BlockingQueue&lt;QueuedRequest&gt; problemSolvingQueue = new LinkedBlockingQueue&lt;&gt;();&#10;  private static final ExecutorService sequentialExecutor = Executors.newSingleThreadExecutor();&#10;  private static volatile String currentlyProcessingRequestId = null;&#10;  private static volatile Session currentlyProcessingSession = null;&#10;  private static volatile Future&lt;?&gt; currentProcessingTask = null;&#10;&#10;  /**&#10;   * Internal class to track queued requests with metadata&#10;   */&#10;  private static class QueuedRequest {&#10;    private final String requestId;&#10;    private final Session session;&#10;    private final String inputMessage;&#10;    private final Map&lt;String, String&gt; configs;&#10;&#10;    public QueuedRequest(String requestId, Session session, String inputMessage, Map&lt;String, String&gt; configs) {&#10;      this.requestId = requestId;&#10;      this.session = session;&#10;      this.inputMessage = inputMessage;&#10;      this.configs = configs;&#10;    }&#10;&#10;    public String getRequestId() { return requestId; }&#10;    public Session getSession() { return session; }&#10;    public String getInputMessage() { return inputMessage; }&#10;    public Map&lt;String, String&gt; getConfigs() { return configs; }&#10;  }&#10;&#10;  static {&#10;    // Start the queue processor&#10;    startQueueProcessor();&#10;  }&#10;&#10;  /**&#10;   * Starts the queue processor that handles problem solving requests sequentially&#10;   */&#10;  private static void startQueueProcessor() {&#10;    sequentialExecutor.submit(() -&gt; {&#10;      while (!Thread.currentThread().isInterrupted()) {&#10;        try {&#10;          // Take the next task from queue (blocks if queue is empty)&#10;          QueuedRequest request = problemSolvingQueue.take();&#10;          currentlyProcessingRequestId = request.getRequestId();&#10;          currentlyProcessingSession = request.getSession();&#10;&#10;          // Check if the session is still open before starting processing&#10;          if (!request.getSession().isOpen()) {&#10;            System.out.println(&quot;Session closed before processing started, skipping request: &quot; + request.getRequestId());&#10;            currentlyProcessingRequestId = null;&#10;            currentlyProcessingSession = null;&#10;            continue;&#10;          }&#10;&#10;          // Update all clients about the current processing status&#10;          broadcastQueueStatus();&#10;&#10;          // Create a separate thread for the actual processing to allow for cancellation&#10;          ExecutorService processingExecutor = Executors.newSingleThreadExecutor();&#10;          currentProcessingTask = processingExecutor.submit(() -&gt; {&#10;            processRequest(request);&#10;          });&#10;&#10;          // Wait for completion or cancellation&#10;          try {&#10;            currentProcessingTask.get();&#10;          } catch (CancellationException e) {&#10;            System.out.println(&quot;Processing was cancelled for request: &quot; + request.getRequestId());&#10;          } catch (ExecutionException e) {&#10;            System.err.println(&quot;Error during processing: &quot; + e.getMessage());&#10;          } finally {&#10;            processingExecutor.shutdown();&#10;          }&#10;&#10;          currentlyProcessingRequestId = null;&#10;          currentlyProcessingSession = null;&#10;          currentProcessingTask = null;&#10;          &#10;          // Update all clients after processing completes&#10;          broadcastQueueStatus();&#10;&#10;        } catch (InterruptedException e) {&#10;          Thread.currentThread().interrupt();&#10;          break;&#10;        } catch (Exception e) {&#10;          System.err.println(&quot;Error processing problem solving queue: &quot; + e.getMessage());&#10;          currentlyProcessingRequestId = null;&#10;          currentlyProcessingSession = null;&#10;          currentProcessingTask = null;&#10;        }&#10;      }&#10;    });&#10;  }&#10;&#10;  /**&#10;   * Processes a single request with periodic client connection checks&#10;   */&#10;  private static void processRequest(QueuedRequest request) {&#10;    Session session = request.getSession();&#10;    &#10;    try {&#10;      // Final check if session is still valid before processing&#10;      if (!session.isOpen()) {&#10;        System.out.println(&quot;Session closed during processing, terminating request: &quot; + request.getRequestId());&#10;        return;&#10;      }&#10;&#10;      // Notify the specific client that processing has started&#10;      sendToSession(session, &quot;{\&quot;type\&quot;:\&quot;SOLVING_PROBLEM_STATEMENT\&quot;, \&quot;data\&quot;:{\&quot;requestId\&quot;:\&quot;&quot; + request.getRequestId() + &quot;\&quot;, \&quot;log\&quot;:\&quot;Processing started for your request...\&quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}}&quot;);&#10;&#10;      // Create a custom implementation that checks for client disconnect during processing&#10;      String result = solveWithClientCheck(request);&#10;&#10;      // Only send result if client is still connected&#10;      if (session.isOpen()) {&#10;        sendToSession(session, &quot;{\&quot;type\&quot;:\&quot;PROBLEM_STATEMENT_SOLVED\&quot;, \&quot;data\&quot;:{\&quot;requestId\&quot;:\&quot;&quot; + request.getRequestId() + &quot;\&quot;, \&quot;result\&quot;:&quot; + result + &quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}}&quot;);&#10;      } else {&#10;        System.out.println(&quot;Client disconnected during processing, not sending result for request: &quot; + request.getRequestId());&#10;      }&#10;      &#10;    } catch (Exception e) {&#10;      // Check if the exception was caused by cancellation due to client disconnect&#10;      if (Thread.currentThread().isInterrupted() || e instanceof InterruptedException) {&#10;        System.out.println(&quot;Processing interrupted for disconnected client: &quot; + request.getRequestId());&#10;        return;&#10;      }&#10;      &#10;      String errorMsg = &quot;Error while solving problem statement: &quot; + e.getMessage();&#10;      try {&#10;        // Only send error if client is still connected&#10;        if (session.isOpen()) {&#10;          sendToSession(session, &quot;{\&quot;type\&quot;:\&quot;PROBLEM_STATEMENT_SOLVED\&quot;, \&quot;data\&quot;:{\&quot;requestId\&quot;:\&quot;&quot; + request.getRequestId() + &quot;\&quot;, \&quot;error\&quot;:\&quot;&quot; + errorMsg + &quot;\&quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}}&quot;);&#10;        }&#10;      } catch (Exception sendException) {&#10;        System.err.println(&quot;Error sending error message: &quot; + sendException.getMessage());&#10;      }&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Solves the problem with periodic checks for client disconnect&#10;   */&#10;  private static String solveWithClientCheck(QueuedRequest request) throws Exception {&#10;    Session session = request.getSession();&#10;    &#10;    // Check client connection one more time before starting the actual solve&#10;    if (!session.isOpen()) {&#10;      throw new RuntimeException(&quot;Client disconnected before solving started&quot;);&#10;    }&#10;    &#10;    // Use the existing solve method - the cancellation will be handled by the task interruption&#10;    return ProblemStatementStudio.getInstance().solve(request.getInputMessage(), request.getConfigs());&#10;  }&#10;&#10;  /**&#10;   * Broadcasts queue status to all connected clients&#10;   */&#10;  private static void broadcastQueueStatus() {&#10;    int queueSize = problemSolvingQueue.size();&#10;    String status = &quot;{\&quot;type\&quot;:\&quot;QUEUE_STATUS\&quot;, \&quot;data\&quot;:{\&quot;queueSize\&quot;:&quot; + queueSize +&#10;                   &quot;, \&quot;currentlyProcessing\&quot;:\&quot;&quot; + (currentlyProcessingRequestId != null ? currentlyProcessingRequestId : &quot;&quot;) +&#10;                   &quot;\&quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}}&quot;;&#10;&#10;    broadcastToAllSessions(status);&#10;  }&#10;&#10;  /**&#10;   * Sends a message to all connected sessions&#10;   */&#10;  private static void broadcastToAllSessions(String message) {&#10;    for (Session session : sessions) {&#10;      sendToSession(session, message);&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Safely sends a message to a specific session&#10;   */&#10;  private static void sendToSession(Session session, String message) {&#10;    try {&#10;      if (session.isOpen()) {&#10;        session.getRemote().sendString(message);&#10;      }&#10;    } catch (IOException e) {&#10;      System.err.println(&quot;Error sending message to session: &quot; + e.getMessage());&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Interface for streaming logs back to the client during problem solving&#10;   */&#10;  public interface LogStreamer {&#10;    void streamLog(String logMessage);&#10;    void streamError(String errorMessage);&#10;    void streamComplete(String result);&#10;  }&#10;&#10;  @OnWebSocketConnect&#10;  public void onConnect(Session session) {&#10;    try {&#10;      sessions.add(session);&#10;      // Register session for log streaming&#10;      WebSocketLogAppender.addSession(session);&#10;      System.out.println(&quot;Client connected: &quot; + session + &quot; (Total clients: &quot; + sessions.size() + &quot;)&quot;);&#10;&#10;      // Send welcome message with current queue status&#10;      int queueSize = problemSolvingQueue.size();&#10;      String welcomeMessage = &quot;{\&quot;type\&quot;:\&quot;CONNECTED\&quot;, \&quot;data\&quot;:{\&quot;message\&quot;:\&quot;Connected successfully\&quot;, \&quot;queueSize\&quot;:&quot; + queueSize +&#10;                             &quot;, \&quot;currentlyProcessing\&quot;:\&quot;&quot; + (currentlyProcessingRequestId != null ? currentlyProcessingRequestId : &quot;&quot;) +&#10;                             &quot;\&quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}}&quot;;&#10;      sendToSession(session, welcomeMessage);&#10;&#10;    } catch (Exception e) {&#10;      e.printStackTrace();&#10;    }&#10;  }&#10;&#10;  @OnWebSocketMessage&#10;  public void onMessage(Session session, String message) throws IOException {&#10;    try {&#10;      WSData data = Helper.getObjectMapper().readValue(message, WSData.class);&#10;      if (data.getEvent().equals(WSEvent.PING)) {&#10;        sendToSession(session, &quot;{\&quot;type\&quot;:\&quot;PONG\&quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}&quot;);&#10;      }&#10;&#10;      if (data.getEvent().equals(WSEvent.SOLVE_PROBLEM_STATEMENT)) {&#10;        handleSolveProblemStatement(session, data.getDataNode());&#10;      } else {&#10;        System.err.println(&quot;Unknown event type: &quot; + data.getEvent());&#10;      }&#10;&#10;    } catch (Exception e) {&#10;      System.err.println(&quot;Error parsing message: &quot; + message);&#10;      e.printStackTrace();&#10;      sendToSession(session, &quot;{\&quot;type\&quot;:\&quot;ERROR\&quot;, \&quot;message\&quot;:\&quot;Invalid message format\&quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}&quot;);&#10;    }&#10;  }&#10;&#10;  @OnWebSocketClose&#10;  public void onClose(Session session, int statusCode, String reason) {&#10;    sessions.remove(session);&#10;    // Unregister session from log streaming&#10;    WebSocketLogAppender.removeSession(session);&#10;    System.out.println(&quot;Client disconnected: &quot; + reason + &quot; (Remaining clients: &quot; + sessions.size() + &quot;)&quot;);&#10;&#10;    // Remove any pending requests from this session from the queue&#10;    problemSolvingQueue.removeIf(request -&gt; request.getSession().equals(session));&#10;&#10;    // If the currently processing session is this session, cancel the processing&#10;    if (currentlyProcessingSession != null &amp;&amp; currentlyProcessingSession.equals(session)) {&#10;      cancelCurrentProcessingTask();&#10;    }&#10;&#10;    // Broadcast updated queue status to remaining clients&#10;    broadcastQueueStatus();&#10;  }&#10;&#10;  @OnWebSocketError&#10;  public void onError(Session session, Throwable throwable) {&#10;    System.err.println(&quot;Error in session &quot; + session + &quot;: &quot; + throwable.getMessage());&#10;    throwable.printStackTrace();&#10;  }&#10;&#10;  // Helper methods to handle different events&#10;&#10;  /**&#10;   * Handles the SOLVE_PROBLEM_STATEMENT event.&#10;   * Adds the request to a queue for sequential processing to prevent concurrent executions.&#10;   * Provides queue position feedback to the client and broadcasts status to all clients.&#10;   *&#10;   * @param session The WebSocket session of the client.&#10;   * @param dataNode The JSON data node containing the problem statement details.&#10;   */&#10;  private void handleSolveProblemStatement(Session session, JsonNode dataNode) {&#10;    String requestId = UUID.randomUUID().toString();&#10;    String inputMessage = dataNode.get(&quot;problemStatement&quot;).toString();&#10;&#10;    JsonNode configNode = dataNode.get(&quot;config&quot;);&#10;    Map&lt;String, String&gt; configs = new HashMap&lt;&gt;();&#10;&#10;    // Flatten configNode if present&#10;    if (configNode != null &amp;&amp; !configNode.isNull()) {&#10;      flattenJson(configNode, &quot;&quot;, configs);&#10;    }&#10;&#10;    // Create queued request&#10;    QueuedRequest queuedRequest = new QueuedRequest(requestId, session, inputMessage, configs);&#10;&#10;    // Get current queue position (before adding)&#10;    int queuePosition = problemSolvingQueue.size() + 1;&#10;&#10;    // Add to queue&#10;    problemSolvingQueue.offer(queuedRequest);&#10;&#10;    // Notify the requesting client about queue position&#10;    try {&#10;      if (queuePosition == 1 &amp;&amp; currentlyProcessingRequestId == null) {&#10;        sendToSession(session, &quot;{\&quot;type\&quot;:\&quot;SOLVING_PROBLEM_STATEMENT\&quot;, \&quot;data\&quot;:{\&quot;requestId\&quot;:\&quot;&quot; + requestId + &quot;\&quot;, \&quot;log\&quot;:\&quot;Request queued - processing will start shortly...\&quot;, \&quot;queuePosition\&quot;:&quot; + queuePosition + &quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}}&quot;);&#10;      } else {&#10;        sendToSession(session, &quot;{\&quot;type\&quot;:\&quot;SOLVING_PROBLEM_STATEMENT\&quot;, \&quot;data\&quot;:{\&quot;requestId\&quot;:\&quot;&quot; + requestId + &quot;\&quot;, \&quot;log\&quot;:\&quot;Request queued at position &quot; + queuePosition + &quot;. Waiting for previous requests to complete...\&quot;, \&quot;queuePosition\&quot;:&quot; + queuePosition + &quot;, \&quot;timestamp\&quot;:&quot; + System.currentTimeMillis() + &quot;}}&quot;);&#10;      }&#10;    } catch (Exception e) {&#10;      System.err.println(&quot;Error sending queue position message: &quot; + e.getMessage());&#10;    }&#10;&#10;    // Broadcast queue status update to all clients&#10;    broadcastQueueStatus();&#10;  }&#10;&#10;  /**&#10;   * Recursively flattens a JsonNode into a dot-notated map.&#10;   */&#10;  private void flattenJson(JsonNode node, String prefix, Map&lt;String, String&gt; result) {&#10;    if (node.isObject()) {&#10;      node.fieldNames().forEachRemaining(fieldName -&gt; {&#10;        String newPrefix = prefix.isEmpty() ? fieldName : prefix + &quot;.&quot; + fieldName;&#10;        flattenJson(node.get(fieldName), newPrefix, result);&#10;      });&#10;    } else if (node.isArray()) {&#10;      for (int i = 0; i &lt; node.size(); i++) {&#10;        String newPrefix = prefix + &quot;[&quot; + i + &quot;]&quot;;&#10;        flattenJson(node.get(i), newPrefix, result);&#10;      }&#10;    } else { // Value node&#10;      result.put(prefix, node.asText());&#10;    }&#10;  }&#10;&#10;  /**&#10;   * Cancels the currently running processing task, if any.&#10;   */&#10;  private static void cancelCurrentProcessingTask() {&#10;    if (currentProcessingTask != null &amp;&amp; !currentProcessingTask.isDone()) {&#10;      currentProcessingTask.cancel(true);&#10;      System.out.println(&quot;Cancelled the currently running processing task.&quot;);&#10;    }&#10;  }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/logback.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/logback.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;configuration&gt;&#10;    &#10;    &lt;!-- Console appender for normal logging --&gt;&#10;    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;&#10;        &lt;encoder&gt;&#10;            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;&#10;        &lt;/encoder&gt;&#10;    &lt;/appender&gt;&#10;    &#10;    &lt;!-- File appender for persistent logging --&gt;&#10;    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;&#10;        &lt;file&gt;logs/scheduler.log&lt;/file&gt;&#10;        &lt;encoder&gt;&#10;            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;&#10;        &lt;/encoder&gt;&#10;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;&#10;            &lt;fileNamePattern&gt;logs/scheduler.%d{yyyy-MM-dd}.%i.log.gz&lt;/fileNamePattern&gt;&#10;            &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt;&#10;            &lt;maxHistory&gt;30&lt;/maxHistory&gt;&#10;            &lt;totalSizeCap&gt;1GB&lt;/totalSizeCap&gt;&#10;        &lt;/rollingPolicy&gt;&#10;    &lt;/appender&gt;&#10;    &#10;    &lt;!-- WebSocket appender for streaming logs --&gt;&#10;    &lt;appender name=&quot;WEBSOCKET&quot; class=&quot;com.greyorange.mvts.designer.WebSocketLogAppender&quot;&gt;&#10;        &lt;encoder&gt;&#10;            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg&lt;/pattern&gt;&#10;        &lt;/encoder&gt;&#10;    &lt;/appender&gt;&#10;    &#10;    &lt;!-- Root logger configuration --&gt;&#10;    &lt;root level=&quot;INFO&quot;&gt;&#10;        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;&#10;        &lt;appender-ref ref=&quot;FILE&quot;/&gt;&#10;        &lt;appender-ref ref=&quot;WEBSOCKET&quot;/&gt;&#10;    &lt;/root&gt;&#10;    &#10;    &lt;!-- Specific logger configurations for better control --&gt;&#10;    &lt;logger name=&quot;com.greyorange.multifleetplanner&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;&#10;        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;&#10;        &lt;appender-ref ref=&quot;FILE&quot;/&gt;&#10;        &lt;appender-ref ref=&quot;WEBSOCKET&quot;/&gt;&#10;    &lt;/logger&gt;&#10;    &#10;    &lt;logger name=&quot;com.greyorange.mvts&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt;&#10;        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;&#10;        &lt;appender-ref ref=&quot;FILE&quot;/&gt;&#10;        &lt;appender-ref ref=&quot;WEBSOCKET&quot;/&gt;&#10;    &lt;/logger&gt;&#10;    &#10;&lt;/configuration&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>